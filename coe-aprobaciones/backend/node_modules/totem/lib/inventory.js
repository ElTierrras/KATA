// Generated by CoffeeScript 1.6.3
(function() {
  var Inventory, Lang;

  Lang = require("./util/lang");

  Inventory = (function() {
    function Inventory(categories, assets) {
      this.categories = categories;
      this.setAssets(assets);
    }

    Inventory.prototype.setAssets = function(assets) {
      this.assets = assets;
    };

    Inventory.prototype.representation = function(_representation) {
      this._representation = _representation;
    };

    Inventory.prototype.good = function(_good) {
      this._good = _good;
    };

    Inventory.prototype.category = function(_category) {
      this._category = _category;
    };

    Inventory.prototype.get = function(options) {
      var assets, tree;
      if (options == null) {
        options = {};
      }
      assets = Lang.clone(this.assets);
      options = this.checkGetOptions(options);
      tree = this.scopeByRepresentation(assets, options.representation);
      tree = this.categoriseAssets(tree);
      if (options.category != null) {
        tree = this.scopeByCategory(tree, options.category);
      }
      if (options.good != null) {
        tree = this.scopeByGood(tree, options.good);
      } else {
        tree = this.unpackFromGoods(tree, options.category == null);
      }
      return tree;
    };

    Inventory.prototype.getAsset = function(assetLabel, representation) {
      if (representation == null) {
        representation = this._representation;
      }
      return this.assetByLabel(assetLabel, representation);
    };

    Inventory.prototype.assetById = function(assetId, representation) {
      if (representation == null) {
        representation = null;
      }
      return this.assetBy("Id", assetId, representation);
    };

    Inventory.prototype.assetByLabel = function(assetLabel, representation) {
      if (representation == null) {
        representation = null;
      }
      return this.assetBy("Label", assetLabel, representation);
    };

    Inventory.prototype.randomEnsemble = function(options) {
      var assets, c, categories, category, ensemble, inventory, palette, _i, _len;
      ensemble = {};
      inventory = this.get(options);
      categories = (function() {
        var _i, _len, _ref, _results;
        _ref = this.categories;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          _results.push(c.Label);
        }
        return _results;
      }).call(this);
      for (_i = 0, _len = categories.length; _i < _len; _i++) {
        category = categories[_i];
        if ((assets = inventory[category])) {
          ensemble[category] = this.random(assets);
        }
      }
      if ((palette = options.palette)) {
        this.colourise(ensemble, palette, options.globalPalette);
      }
      return ensemble;
    };

    Inventory.prototype.avatarEnsemble = function(assets, representation) {
      var asset, categoriesById, category, completeAsset, ensemble, _i, _len;
      ensemble = {};
      categoriesById = this.byId(this.categories);
      for (_i = 0, _len = assets.length; _i < _len; _i++) {
        asset = assets[_i];
        completeAsset = this.completeAsset(asset);
        category = categoriesById[completeAsset.CategoryId];
        completeAsset = this.collapseAssetRepresentation(completeAsset, representation);
        completeAsset.Colour1 = asset.Colour1;
        completeAsset.Colour2 = asset.Colour2;
        ensemble[category] = completeAsset;
      }
      return ensemble;
    };

    Inventory.prototype.assetBy = function(property, value, representation) {
      var asset, assets, found, good, _i, _len, _ref;
      found = null;
      _ref = this.assets;
      for (good in _ref) {
        assets = _ref[good];
        for (_i = 0, _len = assets.length; _i < _len; _i++) {
          asset = assets[_i];
          if (String(asset[property]) === String(value)) {
            found = Lang.clone(asset);
          }
        }
      }
      if (!found) {
        console.log("Inventory couldn't find asset with " + property + " " + value);
      }
      if (representation) {
        found = this.collapseAssetRepresentation(found, representation);
      }
      return found;
    };

    Inventory.prototype.completeAsset = function(asset) {
      if (typeof asset === "string") {
        asset = this.assetByLabel(asset);
      }
      if (asset.Id) {
        return Lang.clone(asset);
      } else {
        return this.assetById(asset.AssetId);
      }
    };

    Inventory.prototype.colourise = function(ensemble, palette, global) {
      var asset, category, colour1, colour2, _ref, _ref1, _ref2, _ref3;
      if (global) {
        colour1 = this.randomColourFrom((_ref = palette.global) != null ? _ref.colour1 : void 0);
        colour2 = this.randomColourFrom((_ref1 = palette.global) != null ? _ref1.colour2 : void 0);
      }
      for (category in ensemble) {
        asset = ensemble[category];
        asset.Colour1 = colour1 || this.randomColourFrom((_ref2 = palette[category]) != null ? _ref2.colour1 : void 0);
        asset.Colour2 = colour2 || this.randomColourFrom((_ref3 = palette[category]) != null ? _ref3.colour2 : void 0);
      }
      return ensemble;
    };

    Inventory.prototype.randomColourFrom = function(palette) {
      if (!((palette != null ? palette.length : void 0) > 0)) {
        return null;
      }
      return this.random(palette);
    };

    Inventory.prototype.checkGetOptions = function(options) {
      if (options.representation == null) {
        options.representation = this._representation;
      }
      if (options.category == null) {
        options.category = this._category;
      }
      if (options.good == null) {
        options.good = this._good;
      }
      if (options.representation == null) {
        throw new Error("You must set options.representation when calling\nInventory::get.");
      }
      if (!this.validate(this.categories, options.category)) {
        throw new Error("Inventory::get: '" + options.category + "' is not a valid category.");
      }
      if ((options.good != null) && (this.assets[options.good] == null)) {
        throw new Error("Inventory::get: '" + options.good + "' is not a valid good.");
      }
      return options;
    };

    Inventory.prototype.validate = function(collection, option) {
      var e, _i, _len;
      if (option == null) {
        return true;
      }
      for (_i = 0, _len = collection.length; _i < _len; _i++) {
        e = collection[_i];
        if (e.Label === option) {
          return true;
        }
      }
      return false;
    };

    Inventory.prototype.scopeByRepresentation = function(tree, representation) {
      var asset, assets, collapsedAsset, good, scopedTree, _i, _len;
      scopedTree = {};
      for (good in tree) {
        assets = tree[good];
        scopedTree[good] = [];
        for (_i = 0, _len = assets.length; _i < _len; _i++) {
          asset = assets[_i];
          collapsedAsset = this.collapseAssetRepresentation(asset, representation);
          if (collapsedAsset.Layers != null) {
            scopedTree[good].push(collapsedAsset);
          }
        }
      }
      return scopedTree;
    };

    Inventory.prototype.collapseAssetRepresentation = function(asset, representation) {
      var foundRepresentation, r, _i, _len, _ref;
      if (asset.Layers) {
        return asset;
      }
      foundRepresentation = null;
      _ref = asset.Representations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        if (!(r.Label === representation)) {
          continue;
        }
        foundRepresentation = r;
        asset.Thumbnail = r.Thumbnail;
        asset.Layers = r.Layers;
        asset.Layers.sort(function(a, b) {
          return a.SortOrder - b.SortOrder;
        });
      }
      delete asset.Representations;
      return asset;
    };

    Inventory.prototype.scopeByCategory = function(tree, category) {
      var assets, good, scopedTree;
      scopedTree = {};
      for (good in tree) {
        assets = tree[good];
        scopedTree[good] = (assets != null ? assets[category] : void 0) || [];
      }
      return scopedTree;
    };

    Inventory.prototype.scopeByGood = function(tree, good) {
      return tree[good];
    };

    Inventory.prototype.categoriseAssets = function(tree) {
      var asset, assets, categories, categorisedTree, categoryLabel, good, _base, _i, _len;
      categorisedTree = {};
      categories = this.byId(this.categories);
      for (good in tree) {
        assets = tree[good];
        categorisedTree[good] = {};
        for (_i = 0, _len = assets.length; _i < _len; _i++) {
          asset = assets[_i];
          categoryLabel = categories[asset.CategoryId];
          if ((_base = categorisedTree[good])[categoryLabel] == null) {
            _base[categoryLabel] = [];
          }
          categorisedTree[good][categoryLabel].push(asset);
        }
      }
      return categorisedTree;
    };

    Inventory.prototype.unpackFromGoods = function(tree, categorised) {
      var assets, category, contents, good, unpacked;
      unpacked = categorised ? {} : [];
      for (good in tree) {
        contents = tree[good];
        if (!categorised) {
          unpacked = unpacked.concat(contents);
        } else {
          for (category in contents) {
            assets = contents[category];
            if (unpacked[category] == null) {
              unpacked[category] = [];
            }
            unpacked[category] = unpacked[category].concat(assets);
          }
        }
      }
      return unpacked;
    };

    Inventory.prototype.byId = function(ary) {
      var byId, o, _i, _len;
      byId = {};
      for (_i = 0, _len = ary.length; _i < _len; _i++) {
        o = ary[_i];
        byId[o.Id] = o.Label;
      }
      return byId;
    };

    Inventory.prototype.random = function(ary) {
      var idx;
      idx = Math.floor(Math.random() * ary.length);
      return ary[idx] || null;
    };

    return Inventory;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Inventory;
  }

}).call(this);
