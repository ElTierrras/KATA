// Generated by CoffeeScript 1.6.3
(function() {
  var AuthService, AuthorizedUser, Avatar, CanvasElementAdaptor, ColourisableUListElementAdaptor, Compositor, DrawingService, GeneratorColourisableUListElementAdaptor, GuestUser, Inventory, Lang, PaymentService, PurchaseService, Totem, UListElementAdaptor, hapilib,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  hapilib = require("hapilib/lib/solo/index");

  AuthorizedUser = require("./user/authorized");

  GuestUser = require("./user/guest");

  Avatar = require("./avatar");

  Inventory = require("./inventory");

  Compositor = require("./drawing/compositor");

  CanvasElementAdaptor = require("./drawing/adaptor/canvasElement");

  UListElementAdaptor = require("./drawing/adaptor/uListElement");

  ColourisableUListElementAdaptor = require("./drawing/adaptor/colourisableUListElement");

  GeneratorColourisableUListElementAdaptor = require("./drawing/adaptor/generatorColourisableUListElement");

  DrawingService = require("./drawing/service");

  Lang = require("./util/lang");

  PurchaseService = require("./service/purchase");

  PaymentService = require("./service/payment/hapi");

  AuthService = require("./service/auth");

  Totem = (function() {
    function Totem(params) {
      if ((params != null ? params.clientId : void 0) == null) {
        throw new Error("Totem: you must supply a clientId parameter on construction");
      }
      if (params.endPoint == null) {
        params.endPoint = "";
      }
      hapilib.init({
        endPoint: params.endPoint,
        clientId: params.clientId
      });
      this.client = params.client || hapilib.restClient;
      this.cache = {};
      this.avatarChangeEvents = ["build", "equip", "colour1", "colour2", "colourEnsemble"];
      this.representationChangeEvent = "representationChange";
      this.allAvatarEvents = [].concat(this.avatarChangeEvents, this.representationChangeEvent);
      this.config(params);
    }

    Totem.prototype.config = function(key, value) {
      if (key == null) {
        key = null;
      }
      if (this._config == null) {
        this._config = {};
      }
      if (key === null) {
        return this._config;
      }
      if (typeof value === "undefined") {
        if (typeof key === "object") {
          return this._config = key;
        }
        if (typeof key === "string") {
          return this._config[key];
        }
      }
      this._config[key] = value;
      return value;
    };

    Totem.prototype.authenticate = function(type, data, bootstrap) {
      var d,
        _this = this;
      if (type == null) {
        type = "client";
      }
      if (data == null) {
        data = {};
      }
      if (bootstrap == null) {
        bootstrap = false;
      }
      d = $.Deferred();
      if ((this._user != null) && (type === "client" || this.userIsAuthorized())) {
        return d.resolve();
      }
      this.authService().authenticate(type, data, function(err, response) {
        if (err) {
          return d.reject(err);
        }
        _this.onAuthentication();
        if (!bootstrap) {
          return d.resolve(response);
        }
        return _this.bootstrap().then(d.resolve(response));
      });
      return d.promise();
    };

    Totem.prototype.userIsAuthorized = function() {
      return this.user() instanceof AuthorizedUser;
    };

    Totem.prototype.logout = function() {
      return this.authService().logout();
    };

    Totem.prototype.bootstrap = function() {
      var d, purchaseDefaultGoods,
        _this = this;
      d = $.Deferred();
      purchaseDefaultGoods = this.userIsAuthorized() ? function() {
        return _this.purchaseDefaultGoods();
      } : function() {
        return $.Deferred().resolve();
      };
      purchaseDefaultGoods().then(function() {
        return $.when(_this.inventory(), _this.categories(), _this.goods(), _this.user().goods()).then(function(inventory, categories, goods, userGoods) {
          return d.resolve({
            inventory: inventory,
            categories: categories,
            goods: goods,
            userGoods: userGoods
          });
        });
      });
      return d.promise();
    };

    Totem.prototype.user = function() {
      if (hapilib.user == null) {
        throw new Error("Totem: no active user. Have you authenticated?");
      }
      return this._user || (hapilib.user.Id != null ? this._user = new AuthorizedUser(this.client, hapilib.user) : this._user = new GuestUser(this.client));
    };

    Totem.prototype.categories = function() {
      var d,
        _this = this;
      d = $.Deferred();
      if (this.cache.categories) {
        return d.resolve(Lang.clone(this.cache.categories));
      }
      this.client.get("/categories", function(err, categories) {
        if (err) {
          return d.reject(err);
        }
        categories = _this.sortCategories(categories);
        _this.cache.categories = categories;
        return d.resolve(Lang.clone(categories));
      });
      return d.promise();
    };

    Totem.prototype.goods = function() {
      var d,
        _this = this;
      d = $.Deferred();
      if (this.cache.goods) {
        return d.resolve(Lang.clone(this.cache.goods));
      }
      this.client.get("/goods", function(err, goods) {
        if (err) {
          return d.reject(err);
        }
        _this.cache.goods = goods;
        return d.resolve(Lang.clone(goods));
      });
      return d.promise();
    };

    Totem.prototype.purchase = function(good, options) {
      var d,
        _this = this;
      if (options == null) {
        options = {};
      }
      d = $.Deferred();
      return this.withAuthorization({
        deferred: d,
        action: function() {
          var confStrategy, paymentService, purchaseService;
          paymentService = options.paymentService, purchaseService = options.purchaseService, confStrategy = options.confStrategy;
          if (paymentService == null) {
            paymentService = new PaymentService(_this.client);
          }
          if (purchaseService == null) {
            purchaseService = new PurchaseService;
          }
          return $.when(_this.goods(), _this.user().goods()).then(function(allGoods, userGoods) {
            var params;
            params = {
              good: good,
              allGoods: allGoods,
              userGoods: userGoods,
              user: _this.user(),
              paymentService: paymentService,
              confStrategy: confStrategy
            };
            return purchaseService.purchase(params).then(function(result) {
              if (result.error) {
                return d.resolve(result);
              }
              return _this.refresh().then(function() {
                return d.resolve(result);
              });
            });
          });
        }
      });
    };

    Totem.prototype.purchaseDefaultGoods = function() {
      var tasks,
        _this = this;
      if (this.config("defaultGoods") == null) {
        return $.Deferred().resolve();
      }
      tasks = [];
      return this.user().goods().then(function(goods) {
        var g, good, owned, _i, _len, _ref;
        owned = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = goods.length; _i < _len; _i++) {
            g = goods[_i];
            _results.push(g.Label);
          }
          return _results;
        })();
        _ref = _this.config("defaultGoods");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          good = _ref[_i];
          if (__indexOf.call(owned, good) < 0) {
            (function(good) {
              return tasks.push(_this.purchase(good));
            })(good);
          }
        }
        return $.when.apply($, tasks);
      });
    };

    Totem.prototype.assets = function() {
      return this.user().assets();
    };

    Totem.prototype.inventory = function() {
      var d,
        _this = this;
      d = $.Deferred();
      if (this.cache.inventory != null) {
        return d.resolve(this.cache.inventory);
      }
      $.when(this.categories(), this.assets()).then(function(categories, assets) {
        var inventory;
        inventory = new Inventory(categories, assets);
        inventory.representation(_this.config("representation"));
        _this.cache.inventory = inventory;
        return d.resolve(inventory);
      });
      return d.promise();
    };

    Totem.prototype.refresh = function() {
      var _this = this;
      return this.assets().then(function(assets) {
        return _this.inventory().then(function(inventory) {
          return inventory.setAssets(assets);
        });
      });
    };

    Totem.prototype.avatar = function(representation, attributes) {
      var avatar;
      if (representation == null) {
        representation = null;
      }
      if (attributes == null) {
        attributes = {};
      }
      if (representation == null) {
        representation = this.config("representation");
      }
      attributes.User = this.user().attributes.Id;
      avatar = this.buildAvatar(attributes, null, representation);
      return avatar;
    };

    Totem.prototype.avatars = function(options) {
      var d,
        _this = this;
      if (options == null) {
        options = {};
      }
      d = $.Deferred();
      return this.withAuthorization({
        deferred: d,
        action: function() {
          var builtAvatars, inventory;
          inventory = null;
          builtAvatars = [];
          return $.when(_this.inventory(), _this.user().avatars(options)).then(function(inventory, avatars) {
            var attributes, _i, _len;
            if (!(avatars instanceof Array)) {
              return d.resolve(_this.buildAvatar(avatars, inventory));
            }
            for (_i = 0, _len = avatars.length; _i < _len; _i++) {
              attributes = avatars[_i];
              builtAvatars.push(_this.buildAvatar(attributes, inventory));
            }
            return d.resolve(builtAvatars);
          });
        }
      });
    };

    Totem.prototype.randomise = function(avatar, options, inventory) {
      var ensemble;
      if (options == null) {
        options = {};
      }
      if (inventory == null) {
        inventory = null;
      }
      if (inventory == null) {
        inventory = this.cache.inventory;
      }
      if (inventory == null) {
        throw new Error("Totem::randomise needs an inventory");
      }
      if (options.palette == null) {
        options.palette = this.config("palette");
      }
      if (options.globalPalette == null) {
        options.globalPalette = this.config("globalPalette");
      }
      options.representation = avatar.representation() || this.config("representation");
      ensemble = inventory.randomEnsemble(options);
      return avatar.build(ensemble);
    };

    Totem.prototype.reset = function(avatar, inventory) {
      var assets, ensemble, representation;
      if (inventory == null) {
        inventory = null;
      }
      representation = avatar.representation() || this.config("representation");
      if (inventory == null) {
        inventory = this.cache.inventory;
      }
      if (inventory == null) {
        throw new Error("Totem::reset needs an inventory");
      }
      if (this.config("defaultAssets") == null) {
        throw new Error("Totem::reset needs defaultAssets");
      }
      assets = this.getDefaultAssets(inventory);
      ensemble = inventory.avatarEnsemble(assets, representation);
      avatar.build(ensemble);
      return avatar;
    };

    Totem.prototype.drawOn = function(avatar, canvas, options, service) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if (service == null) {
        service = null;
      }
      if (options.autoDraw == null) {
        options.autoDraw = true;
      }
      if (options.adaptor == null) {
        options.adaptor = this.drawingAdaptor();
      }
      this.attachAvatarEvents(avatar);
      return this.categories().then(function(categories) {
        var c;
        if (service) {
          _this.useDrawingService(service);
        } else {
          service = _this.drawingService((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = categories.length; _i < _len; _i++) {
              c = categories[_i];
              _results.push(c.Label);
            }
            return _results;
          })());
        }
        return _this.startDrawing(avatar, canvas, options, service);
      });
    };

    Totem.prototype.buildAvatar = function(attributes, inventory, representation) {
      var assets, avatar;
      if (inventory == null) {
        inventory = null;
      }
      if (representation == null) {
        representation = null;
      }
      if (inventory == null) {
        inventory = this.cache.inventory;
      }
      if (representation == null) {
        representation = this.config("representation");
      }
      assets = Lang.clone(attributes.Assets);
      delete attributes.Assets;
      avatar = new Avatar(this.client, attributes);
      if (avatar.representation() == null) {
        avatar.representation(representation);
      }
      if ((inventory != null) && (avatar.representation() != null)) {
        avatar = this.dress(avatar, assets, inventory);
      }
      avatar.attachObserver(this, "requiresAuthorization");
      return avatar;
    };

    Totem.prototype.dress = function(avatar, assets, inventory) {
      var ensemble;
      if (assets == null) {
        assets = this.getDefaultAssets(inventory);
      }
      ensemble = inventory.avatarEnsemble(assets, avatar.representation());
      avatar.build(ensemble);
      return avatar;
    };

    Totem.prototype.startDrawing = function(avatar, canvas, options, service) {
      var avatarOnCanvas;
      avatarOnCanvas = service.avatarOnCanvas(canvas);
      if ((avatarOnCanvas != null) && avatarOnCanvas !== avatar) {
        this.detachAvatarEvents(avatarOnCanvas);
      }
      return service.startDrawing(avatar, canvas, options);
    };

    Totem.prototype.changeRepresentation = function(avatar, representation, inventory) {
      var ensemble;
      if (inventory == null) {
        inventory = null;
      }
      if (inventory == null) {
        inventory = this.cache.inventory;
      }
      if (inventory == null) {
        throw new Error("Totem::changeRepresentation needs an inventory");
      }
      ensemble = inventory.avatarEnsemble(avatar.assetList(), representation);
      avatar.build(ensemble);
      return avatar;
    };

    Totem.prototype.getDefaultAssets = function(inventory) {
      var defaultAssets, label, _i, _len, _results;
      defaultAssets = this.config("defaultAssets") || [];
      _results = [];
      for (_i = 0, _len = defaultAssets.length; _i < _len; _i++) {
        label = defaultAssets[_i];
        _results.push(inventory.assetByLabel(label));
      }
      return _results;
    };

    Totem.prototype.attachAvatarEvents = function(avatar) {
      return avatar.attachObserver(this, this.allAvatarEvents);
    };

    Totem.prototype.detachAvatarEvents = function(avatar) {
      return avatar.detachObserver(this, this.allAvatarEvents);
    };

    Totem.prototype.notify = function(event, data) {
      switch (false) {
        case !(data.sender instanceof Avatar):
          return this.respondToAvatarEvent(event, data);
        case !(data.sender instanceof DrawingService):
          return this.respondToDrawingServiceEvent(event, data);
        case !(data.sender instanceof AuthService):
          return this.respondToAuthServiceEvent(event, data);
        default:
          return this.respondToEvent(event, data);
      }
    };

    Totem.prototype.respondToAuthServiceEvent = function(event, data) {
      if (event === "sessionExpired") {
        delete this._user;
        return $(this).trigger("sessionExpired");
      }
    };

    Totem.prototype.respondToEvent = function(event, data) {
      if (event === "requiresAuthorization") {
        return this.respondToAuthorizationRequest(data);
      }
    };

    Totem.prototype.respondToAuthorizationRequest = function(data) {
      if (this.userIsAuthorized()) {
        delete this.blockedAction;
        return typeof data.action === "function" ? data.action() : void 0;
      } else {
        this.blockedAction = data.action;
        return $(this).trigger("requireAuthorization");
      }
    };

    Totem.prototype.withAuthorization = function(params) {
      var _ref;
      this.respondToAuthorizationRequest(params);
      return (_ref = params.deferred) != null ? _ref.promise() : void 0;
    };

    Totem.prototype.onAuthentication = function() {
      delete this._user;
      delete this.cache.inventory;
      this.setAvatarOwnerships();
      return this.runBlockedAction();
    };

    Totem.prototype.runBlockedAction = function() {
      if (typeof this.blockedAction === "function") {
        this.blockedAction();
      }
      return delete this.blockedAction;
    };

    Totem.prototype.respondToAvatarEvent = function(event, data) {
      var _ref;
      data.event = event;
      if (__indexOf.call(this.avatarChangeEvents, event) >= 0) {
        $(this).trigger("avatarChange", [data]);
        return (_ref = this._drawingService) != null ? _ref.autoDraw() : void 0;
      } else if (event === this.representationChangeEvent) {
        return this.changeRepresentation(data.avatar, data.avatar.representation());
      } else {
        return this.respondToEvent(event, data);
      }
    };

    Totem.prototype.respondToDrawingServiceEvent = function(event, data) {
      return $(this).trigger(event, [data]);
    };

    Totem.prototype.byId = function(ary) {
      var byId, o, _i, _len;
      byId = {};
      for (_i = 0, _len = ary.length; _i < _len; _i++) {
        o = ary[_i];
        byId[o.Id] = o.Label;
      }
      return byId;
    };

    Totem.prototype.compositor = function(categories) {
      return new Compositor(categories);
    };

    Totem.prototype.drawingAdaptor = function() {
      var adaptorType, config, _class;
      config = this.config("drawingAdaptor");
      adaptorType = (config != null ? config.type : void 0) || "canvasElement";
      _class = require("./drawing/adaptor/" + adaptorType);
      return new _class(config != null ? config.options : void 0);
    };

    Totem.prototype.authService = function() {
      var _this = this;
      return this._authService || (this._authService = (function() {
        var e, service;
        service = _this.config("authService") || new AuthService(hapilib);
        try {
          service.attachObserver(_this, "sessionExpired");
        } catch (_error) {
          e = _error;
          console.log("AuthService is not Observable --\nyou will not receive notification when a token expires");
        }
        return service;
      })());
    };

    Totem.prototype.useDrawingService = function(service) {
      service.attachObserver(this, ["startedDrawing", "finishedDrawing"]);
      return this._drawingService = service;
    };

    Totem.prototype.drawingService = function(categories) {
      return this._drawingService || this.useDrawingService(new DrawingService(this.compositor(categories)));
    };

    Totem.prototype.setAvatarOwnerships = function() {
      var avatar, _i, _len, _ref, _results;
      if (!((this._drawingService != null) && this.userIsAuthorized())) {
        return;
      }
      _ref = this._drawingService.allAvatars();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        avatar = _ref[_i];
        _results.push(avatar.attributes.User = this.user().attributes.Id);
      }
      return _results;
    };

    Totem.prototype.sortCategories = function(categories) {
      return categories.sort(function(a, b) {
        return a.SortOrder - b.SortOrder;
      });
    };

    return Totem;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Totem;
  }

}).call(this);
